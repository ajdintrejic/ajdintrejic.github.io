---
title: "Building Worklog: a PERN stack web application"
date: 2020-07-18
toc: true
cover: "/worklog/cover.jpg"
categories: ["WorkLog", "projects"]
description: "Building a web based application using PostgreSQL for database, ExpressJS for routing and ReactJS for front end. This app is supposed to help medium sized businesses automate the boring work."
images: 
  - "https://ajdin.io/worklog/cover.jpg"
tags:
  - webdev
  - react
  - node
  - npm
---

## Introduction

I’ll be building a simple web application to log workers' activity. I’ll be using PostgresSQL for database, React for front end and Express for routing the app.
## Functionality

For user: 
- Log work time, location, job details
- Calculate pay/wage automatically

For admin: 
- See all current working users
- See all jobs done by time/category/location etc.
- Automate the boring stuff

## Setting up the environment

I’m running Arch Linux, so this part will be Linux specific.
### Postgres

Thanks to Arch Wiki, this is easy:

1. Install the PostgreSQL package:

```
sudo pacman -S postgresql 
```

Now this will also create a new user postgres.

2. Switch to postgres user:

```
$ sudo -iu postgres
```

3. Initialize db cluster:

```
$ initdb -D /var/lib/postgres/data
The files belonging to this database system will be owned by user "postgres".
This user must also own the server process.

The database cluster will be initialized with locale "en_US.UTF-8".
The default database encoding has accordingly been set to "UTF8".
The default text search configuration will be set to "english".

Data page checksums are disabled.

fixing permissions on existing directory /var/lib/postgres/data ... ok
creating subdirectories ... ok
selecting dynamic shared memory implementation ... posix
selecting default max_connections ... 100
selecting default shared_buffers ... 128MB
selecting default time zone ... Europe/Zagreb
creating configuration files ... ok
running bootstrap script ... ok
performing post-bootstrap initialization ... ok
syncing data to disk ... ok

initdb: warning: enabling "trust" authentication for local connections
You can change this by editing pg_hba.conf or using the option -A, or
--auth-local and --auth-host, the next time you run initdb.

Success. You can now start the database server using:

    pg_ctl -D /var/lib/postgres/data -l logfile start

```

Typing exit in the shell will return us to previous user.

4. Start or enable postgres service: If you start postgres it won’t start again on boot, if you enable it it will run on every boot but not right now. I won’t enable it as I don’t want Postgres running everytime I boot. I can just run this command every time I want to use it:

```
systemctl start postgresql.service
```

I can check if it’s running by running this command:

```sh
$ systemctl status postgresql.service
● postgresql.service - PostgreSQL database server
     Loaded: loaded (/usr/lib/systemd/system/postgresql.service; disabled; vendor preset: disabled)
     Active: active (running) since Fri 2020-07-03 18:51:04 CEST; 3min 16s ago
    Process: 129806 ExecStartPre=/usr/bin/postgresql-check-db-dir ${PGROOT}/data (code=exited, status=0/SUCCESS)
   Main PID: 129809 (postgres)
      Tasks: 7 (limit: 9229)
     Memory: 16.5M
     CGroup: /system.slice/postgresql.service
             ├─129809 /usr/bin/postgres -D /var/lib/postgres/data
             ├─129812 postgres: checkpointer
             ├─129813 postgres: background writer
             ├─129814 postgres: walwriter
             ├─129815 postgres: autovacuum launcher
             ├─129816 postgres: stats collector
             └─129817 postgres: logical replication launcher

Jul 03 18:51:04 yoga systemd[1]: Starting PostgreSQL database server...
Jul 03 18:51:04 yoga postgres[129809]: 2020-07-03 18:51:04.284 CEST [129809] LOG:  starting PostgreSQL 12.3 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 10.1.0, 64-bit
Jul 03 18:51:04 yoga postgres[129809]: 2020-07-03 18:51:04.284 CEST [129809] LOG:  listening on IPv6 address "::1", port 5432
Jul 03 18:51:04 yoga postgres[129809]: 2020-07-03 18:51:04.284 CEST [129809] LOG:  listening on IPv4 address "127.0.0.1", port 5432
Jul 03 18:51:04 yoga postgres[129809]: 2020-07-03 18:51:04.288 CEST [129809] LOG:  listening on Unix socket "/run/postgresql/.s.PGSQL.5432"
Jul 03 18:51:04 yoga postgres[129811]: 2020-07-03 18:51:04.321 CEST [129811] LOG:  database system was shut down at 2020-07-03 18:46:51 CEST
Jul 03 18:51:04 yoga postgres[129809]: 2020-07-03 18:51:04.327 CEST [129809] LOG:  database system is ready to accept connections
Jul 03 18:51:04 yoga systemd[1]: Started PostgreSQL database server.
[ajdin@yoga ~]$ 
```

Note: you could set up a graphical user interface for Postgres like PgAdmin4, but I prefer to use the terminal, so I won’t be doing that.

### Code

I’ll use the VSCode, but the OSS version, it can be installed with

```
sudo pacman -S code
```
{{< image src="/worklog/code.png" alt="nmap scan" position="center" style="border-radius: 0px;" >}}

### Node.js and Node package manager

This is also easy to install, just run this:

```
sudo pacman -S nodejs npm
```

## Actual code

### Front end with React.js

Now we need a boilerplate. This is achieved with a Node module called create-react-app.

```
npx create-react-app worklog-app
```

Difference between npm and npx:

    npm is a tool mainly used to install packages.
    npx is a tool to execute packages.

The code above also creates a directory called worklog-app with following components:

```
worklog-app
├── node_modules
├── package.json
├── package-lock.json
├── public
├── README.md
└── src
```


I’ll start the server with npm start and we will get the React greeter on localhost:3000:

{{< image src="/worklog/react.png" alt="nmap scan" position="center" style="border-radius: 0px;" >}}

For React I’m going to be using a framework called [Ant Design](https://ant.design/). A good tutorial can be found [here](https://ant.design/docs/react/getting-started), but I’ll include some steps anyway.

```
npm install antd
```

Overwrite src/App.js with this:

```jsx
import React from 'react';
import { Button } from 'antd';
import './App.css';

const App = () => (
  <div className="App">
    <Button type="primary">Button</Button>
  </div>
);

export default App;
```

and also add css to src/App.css at the top of the file (I’ve removed the other css properties as they were made for that React boilerplate):

```jsx
@import '~antd/dist/antd.css';
```

and now, we should have a button on localhost:3000

{{< image src="/worklog/button.gif" alt="nmap scan" position="center" style="border-radius: 0px;" >}}

### Trying to open the page with Express

The page can be loaded with npm start but that is not going through Express router. So Now I will configure this quickly before making any front end. I’m going to install express and react-router-dom so we can connect React and Express:

```
npm install express react-router-dom
```

src/index.js has to import the app like this:

```jsx
import React from 'react';
import { render } from 'react-dom';
import { BrowserRouter } from 'react-router-dom';

import './index.css';
import App from './App';

render((
    <BrowserRouter>
        <App/>
    </BrowserRouter>
), document.getElementById('root'));
```

and now App.js should make all the paths to other pages like this:

```jsx
import React, { Component } from 'react';
import { Route, Switch } from 'react-router-dom';
import './App.css';
import Login from './pages/Login';
import Log from './pages/Log';
import History from './pages/History';
import Admin from './pages/Admin'


class App extends Component {
  render() {
    const App = () => (
      <div>
        <Switch>
          <Route exact path='/' component={Login}/>
          <Route path='/log' component={Log}/>
          <Route path='/history' component={History}/>
          <Route path='/admin' component={Admin}/>
        </Switch>
      </div>
    )
    return (
      <Switch>
        <App/>
      </Switch>
    );
  }
}

export default App;
```

I have made these pages quickly and I’ll fix them later and add/remove functionality if I feel like in the end when I build the database.

Front end pages

- [Login page desktop](/worklog/login_desktop.png)
- [Login page mobile](/worklog/login_mobile.png)
- [User log desktop](/worklog/log_desktop.png)
- [User log mobile](/worklog/log_mobile.png)
- [User history page desktop](/worklog/history_desktop.png)
- [User history mobile](/worklog/history_mobile.png)
- [Admin panel desktop](/worklog/admin_desktop.png)
- [Admin panel mobile](/worklog/admin_mobile.png)

Basic authentication

I’m going to briefly explain how is authentication handled by this app. Entry point into this web app is in index.js which opens App.js like this (if there is ‘…’ in a code block, some code there was removed):

```jsx
...
render(
  <BrowserRouter>
    <App />
  </BrowserRouter>,
  document.getElementById("root")
);
```

App.js has a switch so the user can open different websites.

```jsx
...
class App extends Component {
  render() {
    const App = () => (
      <div>
        <Switch>
          <Route exact path="/" component={Login} />
          <ProtectedRoute path="/log" component={Log} />
          <ProtectedRoute path="/history" component={History} />
          <ProtectedRoute path="/admin" component={Admin} />
          <Route path="*" component={() => "404 Not found, what are you doing here?"} />
        </Switch>
      </div>
    );
    return (
      <Switch>
        <App />
      </Switch>
    );
  }
}

export default App;
```

So the user can now open all these sites, if he is authenticated. If he is not he won’t be able to open the switch to the <ProtectedRoute ... />. ProtectedRoute is a custom class I made which checks if the user is authenticated and opens that Route or returns the user to the login page if he is not.

```jsx
...
export const ProtectedRoute = ({ component: Component, ...rest }) => {
  return (
    <Route
      {...rest}
      render={(props) => {
        if (auth.isAuthenticated()) {
          return <Component {...props} />;
        } else {
          return (
            <Redirect
              to={{
                pathname: "/",
                state: {
                  from: props.location,
                },
              }}
            />
          );
        }
      }}
    />
  );
};
```

So what is this class auth? Well it’s a custom class that handles functions like: login(), logout(), isAuthenticated() and so on…

## Connecting the app to Postgres

I need 2 files here:

- createDb.js to create the database (or I can create it with psql, but It’s better to put all the commands in a file so it’s easier to deploy)
- db.js to execute search queries on the database. Postgres for NodeJS requires the package pg.

```
src/db
├── createDb.js
└── db.js
```

The database should look something like this: 

{{< image src="/worklog/sql.png" alt="nmap scan" position="center" style="border-radius: 0px;background-color:#b0b0b0;" >}}

and the coresponding SQL code to create this looks like this:

```sql
CREATE TABLE Town(
  town_name VARCHAR(64) NOT NULL,
  town_id INT NOT NULL,
  PRIMARY KEY (town_id)
);

CREATE TABLE Work_log(
  time_start TIMESTAMP NOT NULL,
  work_id INT NOT NULL,
  time_end TIMESTAMP NOT NULL CONSTRAINT checkTime CHECK(time_end > time_start),
  work_description VARCHAR(128) NOT NULL,
  work_title VARCHAR(32) NOT NULL,
  PRIMARY KEY (work_id)
);

CREATE TABLE Jobs(
  job_id INT NOT NULL,
  job_name VARCHAR(64) NOT NULL,
  PRIMARY KEY (job_id)
);

CREATE TABLE User(
  user_id INT NOT NULL,
  username VARCHAR(32) NOT NULL,
  fullname VARCHAR(32) NOT NULL,
  estimated_hours_per_month INT NOT NULL,
  hourly_wage INT NOT NULL,
  is_admin INT NOT NULL,
  town_id INT NOT NULL,
  job_id INT,
  PRIMARY KEY (user_id),
  FOREIGN KEY (town_id) REFERENCES town(town_id),
  FOREIGN KEY (job_id) REFERENCES Jobs(job_id),
  UNIQUE (username)
);

```

We can transfer these commands into createDb.js like this (example for table town):

```sql
const sql_create_town = `CREATE TABLE Town(
    town_name VARCHAR(64) NOT NULL,
    town_id INT NOT NULL,
    PRIMARY KEY (town_id)
);`;
```

The queries (eg. CREATE, INSERT) can be executed like this:

```jsx
const {Pool} = require('pg');

const pool = new Pool({
    user: 'postgres',
    host: 'localhost',
    database: 'DATABASE NAME',
    password: 'PASSWORD',
    port: 5432,
});

module.exports = {
    query: (text, params) => {
        const start = Date.now();
        return pool.query(text, params)
            .then(res => {
                const duration = Date.now() - start;
                //console.log('executed query', {text, params, duration, rows: res.rows});
                return res;
            });
    },
    pool: pool
}
```

Once the SQL is ready, We need to create a new user for postgres as we don’t want it to be a superuser. In production this should include revoking some rights from this user so the database is more secure.

```sh
[postgres@yoga ~]$ createuser --interactive
Enter name of role to add: work-log-user
Shall the new role be a superuser? (y/n) n
Shall the new role be allowed to create databases? (y/n) n
Shall the new role be allowed to create more new roles? (y/n) n
[postgres@yoga ~]$ 
```

Creating the database:

```sql
[postgres@yoga ~]$ psql
psql (12.3)
Type "help" for help.

postgres=# CREATE DATABASE worklogdb;
CREATE DATABASE
postgres=# GRANT SELECT ON ALL TABLES IN SCHEMA public TO workloguser;
GRANT
postgres=# ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT, UPDATE, INSERT ON TABLES TO workloguser;
ALTER DEFAULT PRIVILEGES
```

I’ve edited the script to create the database, so when I run node src/db/createDb.js it outputs:

```bash
┌[ajdin@yoga] [/dev/pts/1] [master ⚡] 
└[~/Documents/webapp/worklog-app]> node src/db/createDb.js
Creating table town.
Table town created.
Creating table work_log.
Table work_log created.
Creating table jobs.
Table jobs created.
Creating table user.
Table user created.
```

Now the tables are here, we need to provide it with some mock data, I’ll create a new file called mockDb.js which will supply test data to the database so it can be tested. (I won’t populate work_log with data)

```sql
worklogdb=> \dt
              List of relations
 Schema |     Name     | Type  |    Owner    
--------+--------------+-------+-------------
 public | jobs         | table | workloguser
 public | town         | table | workloguser
 public | work_log     | table | workloguser
 public | worklog_user | table | workloguser
(4 rows)

worklogdb=> SELECT * FROM work_log;
 time_start | work_id | time_end | work_description | work_title 
------------+---------+----------+------------------+------------
(0 rows)

worklogdb=> SELECT * FROM worklog_user;
 user_id | username |   fullname   | estimated_hours_per_month | hourly_wage | is_admin | town_id | job_id 
---------+----------+--------------+---------------------------+-------------+----------+---------+--------
       1 | admin    | Ajdin Trejić |                       150 |          20 |        1 |       2 |      1
(1 row)

worklogdb=> SELECT * FROM jobs;
 job_id |       job_name       
--------+----------------------
      1 | posao administratora
(1 row)

worklogdb=> SELECT * FROM town;
 town_name | town_id 
-----------+---------
 Poreč     |       1
 Funtana   |       2
 Rovinj    |       3
 Pazin     |       4
 Novigrad  |       5
(5 rows)

worklogdb=> 
```

So, the database is connected and has mock data.

## Things which are left to do

- Make use of sessions and cookies with express-session middleware (e.g. leaving cookies when user clicks on ‘Remember me on login’, or to enable dark mode).
- Create an admin route for users with is_admin == 1.
- Make front end render data from the database:
	- Create a class which handles the dataflow.
	- Make it secure so no symbols can pass through (so I don’t have problems with SQL injections) and disable DROP TABLE for obvious reasons.
- Add another user which can edit other user data if a regular user entered wrong data, like a more privileged user.
- Make the admin dashboard display all useful info (Current front end only shows data which I thought could be useful).

